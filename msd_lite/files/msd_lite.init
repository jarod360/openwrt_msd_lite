#!/bin/sh /etc/rc.common
# Copyright (C) 2025 Updated MSD Lite

START=99
USE_PROCD=1

NAME="msd_lite"
PROG="/usr/bin/$NAME"
CONFDIR="/tmp/$NAME"

validate_config() {
    local section="$1"
    local enable bind_address
    
    config_get_bool enable "$section" enable 0
    [ "$enable" -eq 1 ] || return 1
    
    config_get bind_address "$section" bind_address
    [ -n "$bind_address" ] || {
        logger -t $NAME "错误：未指定绑定地址"
        return 1
    }
    
    return 0
}

start_service() {
    logger -t $NAME "开始启动服务"
    config_load "$NAME"
    config_foreach start_instance "msd_lite"
}

start_instance() {
    local section="$1"
    local enable bind_address bind_interface source_interface
    local threads thread_bind_cpu hub_drop_slow_client hub_use_polling_for_send
    local hub_zero_copy_on_send hub_persist_when_no_client hub_persist_when_no_source
    local hub_precache_size hub_wait_precache source_ring_buffer_size source_multicast_rejoin_interval
    local multicast_recv_buffer_size
    
    if ! validate_config "$section"; then
        return 1
    fi

    # 获取所有配置参数
    config_get_bool enable "$section" enable 0
    config_get bind_address "$section" bind_address
    config_get bind_interface "$section" bind_interface
    config_get source_interface "$section" source_interface
    config_get threads "$section" threads 0
    config_get_bool thread_bind_cpu "$section" thread_bind_cpu 0
    config_get_bool hub_drop_slow_client "$section" hub_drop_slow_client 0
    config_get_bool hub_use_polling_for_send "$section" hub_use_polling_for_send 0
    config_get_bool hub_zero_copy_on_send "$section" hub_zero_copy_on_send 0
    config_get_bool hub_persist_when_no_client "$section" hub_persist_when_no_client 0
    config_get_bool hub_persist_when_no_source "$section" hub_persist_when_no_source 0
    config_get hub_precache_size "$section" hub_precache_size 2048
    config_get_bool hub_wait_precache "$section" hub_wait_precache 0
    config_get source_ring_buffer_size "$section" source_ring_buffer_size 8192
    config_get source_multicast_rejoin_interval "$section" source_multicast_rejoin_interval 0
    config_get multicast_recv_buffer_size "$section" multicast_recv_buffer_size 512

    # 拆分 IP:Port
    local bind_ip="${bind_address%:*}"
    local bind_port="${bind_address##*:}"

    mkdir -p "$CONFDIR"
    
    # 生成完整配置文件
    cat <<-EOF > "$CONFDIR/$NAME.conf"
<?xml version="1.0" encoding="utf-8"?>
<msd>
    <log><file>/tmp/msd_lite.log</file></log>
    <threadPool>
        <threadsCountMax>${threads}</threadsCountMax>
        <fBindToCPU>$( [ "$thread_bind_cpu" -eq 1 ] && echo "yes" || echo "no")</fBindToCPU>
    </threadPool>
    <HTTP>
        <bindList>
            <bind><address>${bind_ip}:${bind_port}</address><fAcceptFilter>y</fAcceptFilter></bind>
        </bindList>
        <hostnameList><hostname>*</hostname></hostnameList>
    </HTTP>
    <hubProfileList>
        <hubProfile>
            <fDropSlowClients>$( [ "$hub_drop_slow_client" -eq 1 ] && echo "yes" || echo "no")</fDropSlowClients>
            <fSocketTCPNoDelay>yes</fSocketTCPNoDelay>
            <fWaitPrecache>$( [ "$hub_wait_precache" -eq 1 ] && echo "yes" || echo "no")</fWaitPrecache>
            <precache>${hub_precache_size}</precache>
            <ringBufSize>${source_ring_buffer_size}</ringBufSize>
        </hubProfile>
    </hubProfileList>
    <sourceProfileList>
        <sourceProfile>
            <multicast>
                <ifName>${source_interface}</ifName>
                <rejoinTime>${source_multicast_rejoin_interval}</rejoinTime>
                <recvBufSize>${multicast_recv_buffer_size}</recvBufSize>
            </multicast>
        </sourceProfile>
    </sourceProfileList>
</msd>
EOF

    procd_open_instance "$NAME"
    procd_set_param command "$PROG" -c "$CONFDIR/$NAME.conf"
    procd_set_param respawn
    procd_close_instance
    
    logger -t $NAME "服务启动完成，配置文件：$CONFDIR/$NAME.conf"
}

stop_service() {
    logger -t $NAME "停止服务"
    [ -f "$CONFDIR/$NAME.conf" ] && rm -f "$CONFDIR/$NAME.conf"
}

restart() {
    stop
    sleep 2
    start
}

reload_service() {
    restart
}

service_triggers() {
    procd_add_reload_trigger "$NAME"
}
